=== Вначале работаем с группами ===
1)  Готовый интерфейс
    https://2-fc.com/scad/hubopts.php
2)  Создаются сам проект шедулера json
3)  Добавляются хабы
4)  Для хабов добавляются группы
5)  Открывается окно настройки группы
6)  Все сохраняется в проекте
7)  Выложить на сервер 11
    Заходим на 11 сервер и запускаем приложение

8)  Конкретно группа это и есть сабскрайб
9)  Настройки группы - имя, период опроса, ключи 
   -- апи
11) Шедулер - это один из элементов большого проекта
    Шедулер - это бэкенд
    Интерфейс - это манипуляция шедулером на сервере

=== Потом отстраиваем сущности ===
12) Сущности могут быть вложенными


=== Что работает ===

 1) Запросы setEntityParams
 2) subscribe (ограниченно), список сущностей, список параметров, таймаут

10.10.20.8  работают все методы, но может упасть.
10.10.20.11 рабочее но кастрированое
123Root

ws://localhost:8001
ws://10.10.20.8/connect
ws://10.10.20.11/connect

https://docs.google.com/spreadsheets/d/1eeebLxUuE7UycdIj8GcZWOZOvxntw_kshk9I4z83MCw/edit?pli=1#gid=0

https://drive.google.com/drive/folders/1mhYHLd1jfVY-UMuHtkWLUq0Gx2jLc_vH


http://10.10.20.11/admin
admin@admin.ru
E226Dgry

Самое главное это key
и method, и параметры, в зависимости от конкретно АПИ



1) С тебя утверждение описанных мною работ возможно их дополнишь .
2) Срок реализации и демонстрации мне .

1) Создание интерактивного  пользовательского интерфейса.
Написать JavaScript-функцию для реализации динамической подгрузки данных при взаимодействии пользователя без перезагрузки страницы.
2) Реализовать функцию создания проекта в формате JSON-файла "Scheduler" и хранение всех настроек и данных.
         —-Определить структуру JSON-файла: поля для хранения настроек и данных о проекте.
3) Реализовать функцию добавления/редактирования/настройки подключения микросервисов (хабов) с использованием методов API.
    ——Создать форму для ввода необходимой информации о хабе (URL, токен и т.д.).

4) Разработать функцию создания/добавления/редактирования групп хабов.
    ——Создать форму для управления  свойств группы хабов.
    ——Написать функцию для добавления новой группы хабов и редактирования существующих.
5) Реализовать функцию сохранения всех настроек (добавление, редактирование) в локальное хранилище браузера.?или в файл  в локальном хранилище ? 
6) Протестировать работу методов API (подписка, и другие )  в контексте проекта. Не требуется актуальный бэкэнд для тестирования.
7) Произвести деплой интерфейса на 11 сервер.
8)Связать интерфейс с тестовыми данными для их отображения в проекте.


*** Дублирование данных для разных хостов
 - один хаб отпал, данные можно из другого хаба
 - для обработки и математики
 - смещение
 // Ведущий - ведомый
 // Порог срабатывания, данны разные

 // Параллели(разные)
 // Дата-ченж - это сабскрайб, выполнение по измеениею
 // передаем массив объектов в качестве парамета п1 * 2 и записываем в п1
 
 // дебаггер с брейкпойнтами - это первый вариант
 // Могут выдаваться все связки
 // Должен быть контракт, и он не описан еще

 // p1,p2 скрипты пишет интегратор
 // в момент завершения скрипта
 // все значения каждый
 // Интеграция скедьюлера с любой БД, и любые значения. Стандартная работа с СУБД
 Скрипт пишет программист
 SQL * FROM 
 // SQL и другие базы данных, обертка для них и процессинг SQL в коде

"Scheduler" (или распределитель) - это программа или часть операционной
системы, которая управляет и контролирует выполнение задач на компьютере или в
компьютерной системе. Ее основная задача - определить, какие задачи должны
выполняться в данный момент времени, и какой ресурс (например, процессорное
время) должен быть выделен каждой из них. С помощью распределителя задач можно
обеспечивать справедливость доступа к ресурсам, предотвращать конфликты и сбои
в системе, а также улучшать производительность.

В многозадачных операционных системах, таких как Windows, Linux, macOS и
другие, существует планировщик задач, который определяет, какие процессы или
задачи будут выполняться, и в каком порядке. Планировщик учитывает приоритеты
задач, степень их загрузки, а также другие факторы, чтобы обеспечить
эффективное и справедливое распределение ресурсов. Планировщики могут иметь
различные алгоритмы планирования, такие как Round Robin, Priority Scheduling,
или другие, в зависимости от целей и характеристик операционной системы. Важно,
чтобы планировщик задач обеспечивал оптимальное использование ресурсов и
удовлетворял требованиям приложений и пользователей.

Round Robin (круговая очередь) - это один из наиболее распространенных
алгоритмов планирования в многозадачных операционных системах. Этот алгоритм
используется для распределения процессорного времени между несколькими задачами
в циклическом порядке. Он предоставляет справедливое распределение
процессорного времени между задачами и предотвращает долгое ожидание для каждой
из них.

Принцип работы алгоритма Round Robin следующий:

Каждой задаче присваивается фиксированный квант времени (time quantum), например, 10 миллисекунд.

Задачи выполняются в порядке очереди. Первая задача в очереди получает
процессорное время в течение кванта времени. Если задача завершает свою работу
до истечения кванта, она освобождает процессор, и следующая задача в очереди
начинает выполнение.

Если задача не завершила выполнение до истечения кванта времени, она
перемещается в конец очереди, и другие задачи получают шанс выполниться.

Процесс повторяется до тех пор, пока все задачи не будут выполнены.

Алгоритм Round Robin обеспечивает справедливое распределение процессорного
времени между задачами, что особенно важно в многозадачных системах. Он также
обеспечивает отзывчивость системы, так как каждая задача получает свой квант
времени для выполнения, даже если есть другие активные задачи. Однако этот
алгоритм может привести к небольшим задержкам, особенно если у задачи есть
большая очередь на выполнение, и кванты времени слишком короткие.

Round Robin - это один из базовых алгоритмов планирования и может
использоваться в различных операционных системах и приложениях.

В системе, состоящей из SQL, JSON, Redis и React, "шедулеры" инициируются и
управляются различными компонентами системы в зависимости от того, какие задачи
нужно выполнить и когда. Давайте рассмотрим, как каждый из этих компонентов
может инициировать "шедулеры":

SQL базы данных могут использовать триггеры (triggers) и хранимые процедуры
(stored procedures), чтобы автоматически инициировать задачи при определенных
событиях или изменениях в данных. Например, можно настроить триггер для
выполнения определенной задачи при вставке, обновлении или удалении записи в
таблице. JSON:

JSON сам по себе не является активным компонентом, который инициирует
"шедулеры". Однако JSON-данные могут быть использованы другими компонентами,
такими как серверные приложения, для принятия решений о запуске задач на основе
содержания JSON. Redis:

Redis может использоваться для реализации очереди задач (task queue), где
задачи могут быть добавлены в очередь и выполнены в асинхронном режиме.
Серверное приложение может добавлять задачи в Redis-очередь, и
специализированный рабочий процесс (worker) может извлекать и выполнять эти
задачи по мере возможности. React:

В клиентской части React-приложения "шедулеры" могут быть реализованы с
использованием функций setTimeout или setInterval, чтобы запланировать
выполнение определенных задач на стороне клиента. Это может включать в себя
обновление интерфейса пользователя или выполнение определенных действий после
истечения определенного времени. Обратите внимание, что вся система может быть
организована так, чтобы разные компоненты (SQL база данных, серверное
приложение, Redis, React) взаимодействовали между собой и инициировали
"шедулеры" в соответствии с бизнес-логикой и требованиями приложения. Например,
при создании заказа в React-клиенте, серверное приложение может добавить задачу
в Redis-очередь для обработки, а SQL база данных может инициировать триггеры
для выполнения дополнительных задач. Эффективное управление "шедулерами"
требует хорошо спроектированной системной архитектуры и координации между
компонентами системы.

а можно ли писать шедулеры на редисе?

Да, Redis предоставляет механизмы для создания и управления задачами, что
позволяет использовать его для реализации шедулеров. Один из наиболее
популярных способов создания шедулеров на основе Redis - это использование
Sorted Sets и команды ZADD для добавления задач с временными метками
(timestamp) в сортированное множество, где время выполнения задачи служит
ключом сортировки. Затем можно использовать Redis-скрипты или периодические
проверки для определения задач, которые должны быть выполнены в данный момент.

Вот простой пример того, как можно создать простой Redis-шедулер:

Добавление задачи в Redis-шедулер:
python
Copy code
import redis
import time

# Подключение к Redis
r = redis.Redis(host='localhost', port=6379, db=0)

# Добавление задачи с временной меткой в сортированное множество
task_data = {"task_id": "task123", "data": "some_data"}
timestamp = int(time.time()) + 60  # Запланировать выполнение через 60 секунд
r.zadd("scheduler", {json.dumps(task_data): timestamp})
Save to grepper
Проверка Redis-шедулера на задачи, которые должны быть выполнены в данный момент:
python
Copy code
import redis
import json

# Подключение к Redis
r = redis.Redis(host='localhost', port=6379, db=0)

# Получение текущего времени
current_time = int(time.time())

# Получение задач, которые должны быть выполнены сейчас или ранее
tasks_to_execute = r.zrangebyscore("scheduler", 0, current_time)

# Выполнение задач for task in tasks_to_execute: task_data = json.loads(task) #
Здесь можно выполнить нужные действия на основе данных задачи print("Выполнение
задачи:", task_data) # После выполнения задачи ее можно удалить из
Redis-шедулера r.zrem("scheduler", task) Save to grepper Это упрощенный пример
Redis-шедулера. В реальных приложениях можно добавить дополнительные функции,
такие как повторяющиеся задачи, обработку ошибок и т. д.

на  чем пишут шедулеры, это инициирующий скрипт?

Шедулеры в системах могут быть написаны на различных языках программирования, и
выбор конкретного языка зависит от требований и контекста вашего проекта.
Шедулер - это программный компонент, который используется для запуска и
управления задачами в определенное время или через определенные интервалы
времени.

Вот несколько популярных языков программирования, на которых часто пишут
шедулеры и инициирующие скрипты:

Python: Python - популярный язык программирования для написания шедулеров. В
Python есть множество библиотек, таких как schedule, APScheduler, которые
облегчают создание и управление задачами по расписанию.

Node.js: Node.js - отлично подходит для написания асинхронных шедулеров и
инициирующих скриптов. Вы можете использовать библиотеки, такие как node-cron
или создать собственный механизм на основе setTimeout и setInterval.

Ruby: Ruby также может быть использован для создания шедулеров с использованием
библиотеки, например, rufus-scheduler.

Java: Java предоставляет мощные средства для планирования задач, такие как
библиотека Quartz. Она позволяет создавать сложные расписания и управлять
задачами с высокой точностью.

Go: Go имеет встроенную поддержку для создания шедулеров с использованием
time.Ticker или time.After.

Bash или Shell-скрипты: Для простых задач на Unix-подобных системах можно
использовать Bash-скрипты и утилиты, такие как cron, для управления расписанием
выполнения задач.

Инициирующий скрипт - это обычно основной скрипт или приложение, которое
запускает или инициирует работу шедулера. Этот скрипт может быть написан на том
же языке программирования, что и сам шедулер. В инициирующем скрипте вы можете
определять задачи, которые нужно выполнить, и передавать их шедулеру. Например,
в Python вы можете импортировать библиотеку schedule, создать задачи и добавить
их в шедулер для выполнения по расписанию.

Для написания шедулера на PHP вы можете использовать различные методы и
библиотеки, в зависимости от ваших требований. Вот несколько способов создания
шедулера на PHP:

Использование cron:

На Unix-подобных системах, таких как Linux, вы можете использовать стандартный
планировщик задач cron. Создайте текстовый файл с расписанием в формате cron, в
котором указано, когда и какие PHP-скрипты нужно запускать. Затем добавьте этот
файл в список задач cron. Пример файла с расписанием: javascript Copy code * *
* * * /usr/bin/php /путь/к/вашему/скрипту.php Этот пример запускает
/путь/к/вашему/скрипту.php каждую минуту.

Использование библиотеки cron-expression:

Вы можете использовать библиотеку cron-expression, которая позволяет вам
создавать расписания задач в коде PHP с использованием выражений cron. Эта
библиотека делает работу с расписанием более гибкой и программной. Пример
использования: php Copy code require 'vendor/autoload.php';

use Cron\CronExpression;

$cron = CronExpression::factory('* * * * *'); // Каждая минута
if ($cron->isDue()) {
    // Ваш код, который нужно выполнить
}
Использование библиотеки Symfony/Console:

Если у вас есть консольное приложение на базе Symfony, вы можете использовать
библиотеку Symfony/Console, чтобы создать собственные команды, которые можно
запускать по расписанию. Это может быть полезно, если вам нужно выполнить
какие-то определенные действия с вашим приложением. Пример: php Copy code //
Код команды в Symfony Console protected function execute(InputInterface $input,
OutputInterface $output) { // Ваш код, который нужно выполнить } Использование
сторонних библиотек:

Существуют сторонние библиотеки, такие как cron-php/cron-php, которые
предоставляют инструменты для управления расписанием задач в PHP. Вы можете
использовать такие библиотеки для создания своего собственного шедулера. Выбор
метода зависит от вашего проекта и требований. Если у вас уже есть доступ к
планировщику cron на вашем сервере, то это может быть наиболее простым способом
управления расписанием задач на PHP. В противном случае вы можете рассмотреть
другие варианты, такие как использование библиотек или создание собственных
команд в Symfony Console.

В мире Node.js и React нет точного аналога стандартного инструмента
планирования задач, подобного cron, который используется в Unix-подобных
системах. Однако существуют различные библиотеки и инструменты, которые
позволяют вам создавать и управлять расписаниями задач в Node.js и
React-приложениях. Вот несколько таких инструментов и библиотек:

node-cron: node-cron - это библиотека Node.js, которая предоставляет
возможность создавать расписания задач в формате, подобном cron. Вы можете
использовать ее для запуска задач по расписанию в ваших Node.js-приложениях.
Пример использования:

javascript
Copy code
const cron = require('node-cron');

// Запуск задачи каждую минуту
cron.schedule('* * * * *', () => {
  //console.log('Задача выполнилась');
});
node-schedule: node-schedule - это еще одна библиотека для Node.js, предоставляющая удобные инструменты для создания расписаний задач. Она также поддерживает формат, подобный cron. Пример:

javascript
Copy code
const schedule = require('node-schedule');

// Запуск задачи каждую минуту
const job = schedule.scheduleJob('* * * * *', () => {
  //console.log('Задача выполнилась');
});
Agenda: Agenda - это библиотека для Node.js, специализированная на создании задач, которые выполняются по расписанию. Она предоставляет более высокоуровневый интерфейс для создания и управления задачами. Пример:

javascript
Copy code
const Agenda = require('agenda');
const agenda = new Agenda({ db: { address: 'mongodb://localhost/agendaDB' } });

// Определение задачи и ее расписания
agenda.define('моя_задача', (job, done) => {
  //console.log('Задача выполнилась');
  done();
});

// Запуск задачи каждую минуту agenda.every('1 minute', 'моя_задача');
setTimeout и setInterval: В некоторых случаях вы можете использовать
стандартные функции setTimeout и setInterval для выполнения задач по расписанию
в Node.js и React-приложениях. Однако это менее удобный и гибкий способ, чем
использование специализированных библиотек.

Выбор библиотеки зависит от ваших потребностей и предпочтений. Если вам нужно
создавать сложные расписания задач, то node-cron, node-schedule и Agenda
предоставляют более продвинутые возможности.

В Python для создания и управления расписаниями задач часто используют
сторонние библиотеки и модули, такие как schedule, APScheduler, Celery и
другие. Какой тип шедулера использовать зависит от требований вашего проекта.
Вот несколько примеров типов шедулеров, которые могут быть использованы в
Python:

Простой шедулер:

Простой шедулер может быть написан с использованием модуля time для управления
задержками и интервалами времени. Вы можете использовать time.sleep для
создания задержек и запуска задачи через определенные интервалы. Этот тип
шедулера подходит для простых задач и не требует сторонних библиотек.
Библиотека schedule:

Библиотека schedule предоставляет удобные инструменты для создания расписания
задач, основанного на времени и днях недели. Она позволяет создавать задачи,
которые выполняются в определенное время и дни недели. Пример: python Copy code
import schedule import time

def job():
    print("Задача выполнилась")

schedule.every(1).minutes.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)
Библиотека APScheduler:

APScheduler (Advanced Python Scheduler) предоставляет более сложные возможности
планирования задач. Она позволяет создавать задачи, которые могут выполняться
по расписанию, через определенные интервалы времени, или даже в реакции на
определенные события. Она также поддерживает разные хранилища для сохранения
задач и их состояния. Пример: python Copy code from
apscheduler.schedulers.blocking import BlockingScheduler

def job():
    print("Задача выполнилась")

scheduler = BlockingScheduler()
scheduler.add_job(job, 'interval', minutes=1)
scheduler.start()
Библиотека Celery:

Celery - это библиотека для создания распределенных систем обработки задач в
Python. Она предназначена для выполнения задач в фоновом режиме и поддерживает
широкий спектр функциональных возможностей, таких как планирование, обработка
задач в очереди, управление распределенными задачами и многое другое. Тип
шедулера, который вы выберете, зависит от сложности задач, требований к
планированию и вашего опыта с библиотеками Python. Каждый из вышеперечисленных
типов шедулеров имеет свои сильные стороны и может быть использован для
различных сценариев.


В мире Node.js и React нет точного аналога стандартного инструмента планирования задач,
подобного cron, который используется в Unix-подобных системах.
Однако существуют различные библиотеки и инструменты, которые позволяют вам создавать
и управлять расписаниями задач в Node.js и React-приложениях. 
Вот несколько таких инструментов и библиотек:

node-cron: node-cron - это библиотека Node.js, которая предоставляет 
возможность создавать расписания задач в формате, подобном cron. 
Вы можете использовать ее для запуска задач по расписанию в ваших Node.js-приложениях. 
Пример использования:
const cron = require('node-cron');

// Запуск задачи каждую минуту
cron.schedule('* * * * *', () => {
  //console.log('Задача выполнилась');
});


node-schedule: node-schedule - это еще одна библиотека для Node.js,
предоставляющая удобные инструменты для создания расписаний задач. Она также
поддерживает формат, подобный cron. Пример:
const schedule = require('node-schedule');

// Запуск задачи каждую минуту
const job = schedule.scheduleJob('* * * * *', () => {
  //console.log('Задача выполнилась');
});

Agenda: Agenda - это библиотека для Node.js, специализированная на создании
задач, которые выполняются по расписанию. Она предоставляет более
высокоуровневый интерфейс для создания и управления задачами. Пример:
setTimeout и setInterval: В некоторых случаях вы можете использовать
стандартные функции setTimeout и setInterval для выполнения задач по расписанию
в Node.js и React-приложениях. Однако это менее удобный и гибкий способ, чем
использование специализированных библиотек.

const Agenda = require('agenda');
const agenda = new Agenda({ db: { address: 'mongodb://localhost/agendaDB' } });

// Определение задачи и ее расписания
agenda.define('моя_задача', (job, done) => {
  //console.log('Задача выполнилась');
  done();
});

// Запуск задачи каждую минуту
agenda.every('1 minute', 'моя_задача');

Выбор библиотеки зависит от ваших потребностей и предпочтений. Если вам нужно
создавать сложные расписания задач, то node-cron, node-schedule и Agenda
предоставляют более продвинутые возможности.
 