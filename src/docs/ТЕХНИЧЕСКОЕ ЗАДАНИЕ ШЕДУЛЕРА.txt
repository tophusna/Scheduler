=== Вначале работаем с группами ===
1)  Готовый интерфейс
    https://2-fc.com/scad/hubopts.php
2)  Создаются сам проект шедулера json
3)  Добавляются хабы
4)  Для хабов добавляются группы
5)  Открывается окно настройки группы
6)  Все сохраняется в проекте
7)  Выложить на сервер 11
    Заходим на 11 сервер и запускаем приложение

8)  Конкретно группа это и есть сабскрайб
9)  Настройки группы - имя, период опроса, ключи 
   -- апи
11) Шедулер - это один из элементов большого проекта
    Шедулер - это бэкенд
    Интерфейс - это манипуляция шедулером на сервере

=== Потом отстраиваем сущности ===
12) Сущности могут быть вложенными


=== Что работает ===

 1) Запросы setEntityParams
 2) subscribe (ограниченно), список сущностей, список параметров, таймаут

10.10.20.8  работают все методы, но может упасть.
10.10.20.11 рабочее но кастрированое * тестить можно на этом без ключей
123Root

ws://localhost:8001
ws://10.10.20.8/connect
ws://10.10.20.11/connect

https://docs.google.com/spreadsheets/d/1eeebLxUuE7UycdIj8GcZWOZOvxntw_kshk9I4z83MCw/edit?pli=1#gid=0

https://drive.google.com/drive/folders/1mhYHLd1jfVY-UMuHtkWLUq0Gx2jLc_vH


http://10.10.20.11/admin
admin@admin.ru
E226Dgry

Самое главное это key
и method, и параметры, в зависимости от конкретно АПИ

server#pass777

1) С тебя утверждение описанных мною работ возможно их дополнишь .
2) Срок реализации и демонстрации мне .

1) Создание интерактивного  пользовательского интерфейса.
Написать JavaScript-функцию для реализации динамической подгрузки данных при взаимодействии пользователя без перезагрузки страницы.
2) Реализовать функцию создания проекта в формате JSON-файла "Scheduler" и хранение всех настроек и данных.
         —-Определить структуру JSON-файла: поля для хранения настроек и данных о проекте.
3) Реализовать функцию добавления/редактирования/настройки подключения микросервисов (хабов) с использованием методов API.
    ——Создать форму для ввода необходимой информации о хабе (URL, токен и т.д.).

4) Разработать функцию создания/добавления/редактирования групп хабов.
    ——Создать форму для управления  свойств группы хабов.
    ——Написать функцию для добавления новой группы хабов и редактирования существующих.
5) Реализовать функцию сохранения всех настроек (добавление, редактирование) в локальное хранилище браузера.?или в файл  в локальном хранилище ? 
6) Протестировать работу методов API (подписка, и другие )  в контексте проекта. Не требуется актуальный бэкэнд для тестирования.
7) Произвести деплой интерфейса на 11 сервер.
8) Связать интерфейс с тестовыми данными для их отображения в проекте.


*** Дублирование данных для разных хостов
 - один хаб отпал, данные можно из другого хаба
 - для обработки и математики
 - смещение
 // Ведущий - ведомый
 // Порог срабатывания, данные разные

 // Параллели(разные)
 // Дата-ченж - это сабскрайб, выполнение по измеениею
 // передаем массив объектов в качестве парамета п1 * 2 и записываем в п1
 
 // дебаггер с брейкпойнтами - это первый вариант
 // Могут выдаваться все связки
 // Должен быть контракт, и он не описан еще

 // p1,p2 скрипты пишет интегратор
 // в момент завершения скрипта
 // все значения каждый
 // Интеграция скедьюлера с любой БД, и любые значения. Стандартная работа с СУБД
 Скрипт пишет программист
 SQL * FROM 
 // SQL и другие базы данных, обертка для них и процессинг SQL в коде


add_entity (Добавить объект)

   Метод: POST
   Параметры:
   name (обязательно) - Название объекта, который нужно создать.
   key (обязательно) - Ключ подписчика.
   params (обязательно) - Словарь параметров объекта.
   parentGuid (необязательно) - GUID родительского объекта.
   comment (необязательно) - Описание объекта.
   Ответы:
   Успешно: Объект создан с GUID и сообщением об успешном выполнении.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   set_entity_params (Установить параметры объекта)

Метод: POST
   Параметры:
   entityGuid (обязательно) - GUID объекта, параметры которого нужно установить.
   key (обязательно) - Ключ подписчика.
   params (обязательно) - Словарь параметров для установки.
   Ответы:
   Успешно: Параметры обновлены с сообщением об успешном выполнении.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   get_entities (Получить объекты)

Метод: POST
   Параметры:
   key (обязательно) - Ключ подписчика.
   parentGuid (необязательно) - GUID родительского объекта.
   Другие необязательные параметры для ограничения, смещения и поиска.
   Ответы:
   Успешно: Список объектов, соответствующих заданным критериям.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   get_entity (Получить данные объекта)

Метод: POST
   Параметры:
   key (обязательно) - Ключ подписчика.
   entityGuid (обязательно) - GUID объекта для получения данных.
   Ответы:
   Успешно: Детали указанного объекта.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   change_entity (Изменить объект)

Метод: POST
   Параметры:
   key (обязательно) - Ключ подписчика.
   entityGuid (необязательно) - GUID объекта для изменения.
   Другие необязательные параметры, такие как name, comment, parentGuid, params.
   Ответы:
   Успешно: Изменения сохранены с сообщением об успешном выполнении.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   get_alarms (Получить сообщения об ошибке)

Метод: POST
   Параметры:
   key (обязательно) - Ключ подписчика.
   Другие необязательные параметры, такие как limit, offset.
   Ответы:
   Успешно: Список сообщений об ошибке.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   subscribers_ping (Проверить статус подписчиков)

Метод: POST
   Параметры:
   key (обязательно) - Ключ подписчика.
   entityGuid (обязательно) - GUID объекта для проверки.
   Ответы:
   Успешно: Состояние подписчиков обновлено.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   subscribe (Подписаться на данные)

Метод: Соксет (WebSocket)
   Параметры:
   key (обязательно) - Ключ подписчика.
   entities (обязательно) - Массив GUID объектов для подписки.
   method (обязательно) - Название метода.
   Другие необязательные параметры, такие как params, children, change, interval.
   Ответы:
   Успешно: Данные сообщений, полученные в результате подписки.
   Ошибка: Разные сообщения об ошибке в зависимости от проблемы.
   Эти методы представляют собой API для управления объектами и взаимодействия с подписчиками в некоторой системе. Если у вас есть конкретные вопросы или требуется дополнительная информация по какому-либо из этих методов, не стесняйтесь задавать вопросы.

{
  "data": {
    "message": [{
      "entityGuid": "66d95c21-42c4-4491-80b7-e6c6c396144a",
      "entityId": 25,
      "paramId": 38,
      "paramName": "param_one",
      "val": 5633.14,
      "updatedAt": "2023-05-15T10:21:55.000Z"
    }, {
      "entityGuid": "66d95c21-42c4-4491-80b7-e6c6c396144a",
      "entityId": 25,
      "paramId": 39,
      "paramName": "param_two",
      "val": null,
      "updatedAt": "2023-05-15T10:20:05.000Z"
    }, {
      "entityGuid": "66d95c21-42c4-4491-80b7-e6c6c396144a",
      "entityId": 25,
      "paramId": 40,
      "paramName": "param_three",
      "val": 5633.14,
      "updatedAt": "2023-05-15T10:21:55.000Z"
    }]
  },
  "status_code": 200
}

1) источник к шаблону
2) во второй вкладке могут изменить сам шаблон и его название
3) все сущности и группы это js скрипты которые инициирует js шедулеры, которым можно указать
источник шаблона, возможность исправить js шедулер, и возможность создать и сохранить его под новым типом 
шаблонов js шедулеров.
  - взять один из этих 10 и внести в него изменения, сгруппироать их полученные от js указатели к js шедулерам,
  сгруппироать по типам группам, папкам.
4) мы пишем программу, которая редактирует js шедулеры и js скрипты,  которые инициируют js шедулеры
5) сами js шеделуреы пишутся на реакте с помощью программы setTimout, setInterval и js скриптах меняется 
только путь к одному из сохраненных шаблонов js шедулера

1) создать новую сущность, из какого шаблона вы хотите создать новую сущность
2) он выбирает путь, который фактически подставляется в js  скрипт, ведущий к конкретному типу шедулера, 
после чего появляется выбор создания нового скрипта для конкретного шедулера или изменения самого шедулера, 
с последующим сохранением в шаблона. 

Создание и изменение js  шедулеров зависит от прав, кто то может создавать новые шедулеры, либо берут готове.
Стандартные и пользовательские (одному минуту, а другому каждые 3 часа)

Автоматические создание js скрипта для управления шедулером, как редактируемый файл. 
В итоге этот JS скрипт может запускать конкретный js шедулер созданный или измененный пользователем
и записывается.

Оперционная система для управления шедулерами с помощью js
Какие типы данных в конкретном js нужно изменять, откуда он берется?

Мне нужно в какой то папке 5 файлов. 1 из 5 шаблонных текстовых файлов (шедулеров)
js скрипт шедулера, весить на группы

интересы людей, какие могут понадобится навигационные инструменты? 
Это могут знать люди, которые будут пользоваться продуктом

Скрипт состоит из двух частей
 * когда он вызывается, условие вызова (какие данные передаются), из сущностей берем параметры
 * непосредственно код 
 * нажимаем на редактировать // вылетел двойной табшит под основным 
 * при запуске платформы, в общей конфигурации (потом обсудить с бекерами)

 * Реализованно:
1) вэбсокет subscribe - но сейчас  в виде отдельной функции
2) структура многооконного приложения на react, решил использовать для этого генератор + роутер
3) роутинг, с возможностью подгрузки по ссылке
4) окно списка файлов и папок в виде отдельного функционального компонента, но нужно доработать навигацию, сейчас выводит список файлов и папок с иконками из корня
5) окна и заголовки окон
6) функциональный компонент, которые позволят выводить список групп. Добавлять и удалять
7) каждая ссылка имеет свой набор компонентов и окон, который описывается в json
8) структура импортов, компонентов, и папок, для изебежания громоздкого, непонятного кода. Сразу определяем порядок и стиль и придерживаемся лаконичности высокой читаемости кода.
9) сервер, который по axios может отдавать json массив файлов из указанной папки. а так же умеет отдавать post и get


1) сделал группы на редуксе, без него с состояниями будет работать крайне запарно
2) файлменеджер позволяет теперь открывать заходить в папки и подпапки
3) зацепил гит
4) проконсультировался с никитой
5) нужно везде использовать редукс
1) код эдитор в табе 
2) рабочий файлменеджер v1  
3) почти раскурил открытие файлов в кодэдиторе 
4) динамическое меню пользователя с переходами с разными наборами окон из json 
5) документация по redux
6) изучены разные способы реализации шедулеров на разных языках программирования
7) все кроме менеджера хабов уже динамическое и уже на одной странице
8) axios загрузка файл контента из файлменеджера 
9) файлконтент в редуксе
10) закрытие окон крестиком

* Не реализовано:
1) Добавление хабов
2) Добавление сущностей в группы
3) Закрытие окон
4) Добавление удаление хаба
5) На кнопку подключения нужно повесить готовый сабкрайб

* Технические характеристики:
1) Реактивная связь компонентов с вэбсокетом
2) Повторная используемость в подобных задачах
3) Быстрота развертывания типовых задач
4) Масштабируемость, функционал и количество окон и модулей может стремительно расти, уровень сложности связей может тоже расти, поэтому полагаю, что имеет смысл сразу закладывать серьезную архитектуру.
5) Универсальность
6) Динамическая подгрузка - выгрузка по роуту набора окон/компонент из соовтветсвующего системного json, а так же возможность закрывать окна, или открывать любые новые по желанию пользователя.

==========================
** ВТОРАЯ ЧАСТЬ ЗАДАНИЯ **
==========================
Спринт:

1. Создать проект:
   - Это означает, что нужно создать новый проект или рабочую область для работы.

2. Сохранить проект (локально / на сервере):
   - Позволить сохранять проект на вашем компьютере или на удаленном сервере, чтобы вы могли возвращаться к нему позже.

3. Открыть проект (локально / на сервере):
   - Дать возможность открывать ранее созданный проект как на вашем компьютере, так и на удаленном сервере.
   * данные по подпискам 
4. Иметь возможность изменить конфигурацию (нужно добавить сабтаб группы):
   - Добавить функциональность для настройки параметров проекта.
   - Если интервал установлен в ноль, то изменения параметров должны происходить автоматически только при их изменении.
   - Разрешить создание вложенных групп параметров.
   - Если выбрана опция history, система должна сохранять и показывать историю всех изменений, которые произошли в течение секунды.

5. Зайти из браузера по ссылке https://10.10.20.11/scheduler:
   - Предоставить возможность входа в систему через веб-браузер, перейдя по указанной ссылке.

6. Проект сохраняется в формате JSON, который можно открыть онлайн в codeEditor:
   - Проекты должны быть сохранены в формате JSON, что позволит их открывать и редактировать онлайн в специальном редакторе кода.

7. html стэнд
   https://2-fc.com/scad/subsaval.php
====
1) на верхнем уровне идут только хабы!!!
2) менеджер подписок(все дерево) и группы справа - одно и тоже - это представление
3) группы это описание подписки
4) В правом окне двойной клик открывает сабтаб с тингни группы:
5) в топтбах только хабы
6) группу подписок создает пользователь
7) группа принадлежат проекту  и сохраняются в json
8) группа подписок одна и состоит из разных сущностей
9) группа это описание сабскрайба, где есть группа сущностей на которую происходит 
подписка
11) группа подписок всегда одна
 УЖЕ НАХОДЯЩИТСЯ В ПОДПИСКЕ!!! ЭТО В МЕНДЖЕРЕ 
12) подписка идет на определенный хаб и содержит в себе определенные сущности.
Группа подписок формируется здесь. Она всегда одна. 
https://2-fc.com/scad/subsaval.php

Транскрипция:
=============
1) На сервере с IP-адресом 10.10.20.11 развёрнут хаб.

2) Данный хаб размещен на этом сервере.

3) На сервере должен находиться и запускаться Node.js скрипт, который будет взаимодействовать с хабом. Этот скрипт предназначен для работы с Виктором.

4) Для взаимодействия с хабом, я открываю шедулер IDE в веб-браузере, заходя на сервер с IP-адресом 10.10.20.11. После входа, я создаю новый проект.

5) При создании проекта мне предлагается выбрать папку, где проект будет сохранен. Это может быть как на моем компьютере, так и на сервере.

6) Я также могу создать новую папку с стандартной структурой.

7) После выбора опций, проект создается, и соответствующий файл сохраняется.

8) Если необходимо, создается хаб в менеджере подписок.

9) Внутри хаба, я настраиваю параметры хаба и сохраняю их.

10) Для данного хаба, я создаю одну или две группы подписок.

11) В каждой подписке, я выбираю соответствующую сущность, которую хочу отслеживать.

12) После настройки всех параметров, я сохраняю изменения и проверяю, как они сохранились.

13) По мере продвижения, у меня появляется понимание общей структуры системы, и мы двигаемся к следующему этапу, двигаясь поэтапно.

14) Один клиент не должен подключаться к системе, а вместо этого выполняет один разовый запрос для получения данных сущностей (GET-запрос).

15) Возвращенные данные предоставляют сущности.

16) Для передачи данных используется метод POST.

17) Данные поступают обратно в ответ на POST-запрос.

18) В данной системе отсутствует постоянное соединение и подписки, данные обновляются через отдельные запросы.

19) Система подтверждает данные, отправляя их как JSON. Это означает, что система будет отправлять данные в формате JSON.

20) Это происходит непрерывно и моментально. Система отправляет данные немедленно и непрерывно.

21) Если какой-либо параметр изменяется, соответствующее значение этого параметра отправляется мгновенно.

22) Если никакие параметры не изменились, значения параметров всё равно отправляются с интервалом в одну секунду.

23) Здесь может быть нулевой интервал, что означает, что данные отправляются только при изменении.

24) Ноль интервалов означает, что данные отправляются только при изменениях.

25) История обновляется следующим образом.

26) При выборе "истории", активируется нулевой интервал, что означает отправку всех изменений за секунду.

27) Всякие изменения отправляются каждую секунду.

28) Это применимо к параметрам. Изменение параметра может привести к отправке данных.

29) Если параметр изменился 5 раз за секунду, то будет 5 значений в массиве.

30) Если ни разу не изменился, значит, в массиве не будет значений.

31) Последнее значение будет отправлено, если нет изменений.

32) Изменения отправляются каждую секунду.

33) Если ничего не меняется, отправляется последнее значение.

34) Обновление отправляется раз в секунду.

35) Сообщения о изменениях не отправляются, если ничего не изменилось.

36) В зависимости от выбранного интервала, отправляется либо последнее значение, либо все изменения за интервал.

37) Эти изменения распространяются на всю группу сущностей.

38) Множество групп может быть создано в зависимости от конфигурации.

39) Различные сущности могут иметь разные конфигурации.

40) Для некоторых сущностей история не нужна, и они могут получать только последние значения.

41) Решение о применении истории будет зависеть от конечных пользователей.

42) Прикладная часть будет разрабатываться отдельно.

43) Подписка на конкретные сущности и их конфигурации будет настроена пользователем.

44) Подписка действует в соответствии с заданными актами.

45) Подписка активируется по запросу пользователя.

46) Подписка позволяет просматривать значения параметров.

47) Значения параметров могут быть получены через подписку.

48) Подписка активна только по запросу пользователя.

49) Значения нужны только для случайных запросов.

50) Определенные методы выполняются через определенные интервалы.

51) Конфигурация запускается при определенных событиях.

52) Скрипты выполняются в соответствии с конфигурацией.

53) Методы выполняются с определенной периодичностью.

54) Методы могут записывать данные.

55) Данные могут быть сохранены методами.

=========
! Важно
=========
1) Группы в группе быть не может
2) 